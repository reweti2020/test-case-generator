<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Test Case Generator</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f9f9f9;
      padding: 2rem;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    input, select {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 1rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      background: #0070f3;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button:hover {
      background: #0059c1;
    }
    #output {
      margin-top: 1.5rem;
      max-height: 500px;
      overflow-y: auto;
      border: 1px solid #eee;
      padding: 1rem;
      border-radius: 4px;
    }
    pre {
      white-space: pre-wrap;
      word-break: break-all;
      background: #f5f5f5;
      padding: 1rem;
      border-radius: 4px;
      overflow-x: auto;
    }
    h1 {
      color: #333;
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üß™ Test Case Generator</h1>
    <form id="url-form">
      <input type="text" id="url-input" placeholder="Enter website URL" required />
      <select id="format-select">
        <option value="plain">Plain Text</option>
        <option value="katalon">Katalon Format</option>
        <option value="maestro">Maestro Format</option>
      </select>
      <button type="submit">Generate Test Cases</button>
    </form>
    <div id="output"></div>
  </div>

  <script>
    // Debug logger that styles console output for better readability
    const logger = {
      info: (label, data) => {
        console.log(`%cüìù ${label}:`, 'color: #0070f3; font-weight: bold;', data);
      },
      warn: (label, data) => {
        console.warn(`%c‚ö†Ô∏è ${label}:`, 'color: #ff9800; font-weight: bold;', data);
      },
      error: (label, data) => {
        console.error(`%cüõë ${label}:`, 'color: #f44336; font-weight: bold;', data);
      },
      success: (label, data) => {
        console.log(`%c‚úÖ ${label}:`, 'color: #4caf50; font-weight: bold;', data);
      },
      group: (label) => {
        console.group(`%cüìä ${label}`, 'color: #9c27b0; font-weight: bold;');
      },
      groupEnd: () => {
        console.groupEnd();
      }
    };

    document.getElementById('url-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const url = document.getElementById('url-input').value;
      const format = document.getElementById('format-select').value;
      const output = document.getElementById('output');
      
      output.innerHTML = '‚è≥ Generating test cases...';

      logger.group('Test Case Generation Request');
      logger.info('Request Parameters', { url, format });
      
      // Validate URL format on client side first
      let isValidUrl = false;
      try {
        new URL(url);
        isValidUrl = true;
        logger.success('URL Validation', 'Valid URL format');
      } catch (error) {
        logger.error('URL Validation', `Invalid URL format: ${error.message}`);
        output.innerHTML = `<p>‚ùå Error: Invalid URL format. Make sure to include http:// or https://</p>`;
        logger.groupEnd();
        return;
      }

      try {
        logger.info('Sending Request', 'Starting fetch operation');
        const startTime = performance.now();
        
        // Add a client-side timeout as well
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          logger.warn('Request Timeout', 'Client-side timeout triggered after 30 seconds');
          controller.abort();
        }, 30000);
        
        logger.info('Request Details', {
          endpoint: '/api/generate-tests',
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url, format })
        });
        
        // Make the actual request
        const response = await fetch('/api/generate-tests', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ url, format }),
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        const endTime = performance.now();
        logger.info('Response Time', `${Math.round(endTime - startTime)}ms`);
        
        logger.group('Response Details');
        logger.info('Status', response.status);
        logger.info('Status Text', response.statusText);
        logger.info('OK', response.ok);
        
        // Log headers
        const headers = {};
        response.headers.forEach((value, key) => {
          headers[key] = value;
        });
        logger.info('Headers', headers);
        logger.groupEnd();
        
        if (!response.ok) {
          logger.error('Response Error', `Server responded with status: ${response.status}`);
          output.innerHTML = `<p>‚ùå Error: Server responded with status: ${response.status}</p>`;
          
          // Try to get error details if possible
          try {
            const errorText = await response.text();
            logger.error('Error Details', errorText);
            try {
              const errorJson = JSON.parse(errorText);
              logger.error('Error JSON', errorJson);
              if (errorJson.error) {
                output.innerHTML = `<p>‚ùå Error: ${errorJson.error}</p>`;
              }
            } catch (e) {
              // Not JSON, use text
              if (errorText) {
                output.innerHTML += `<pre>${errorText}</pre>`;
              }
            }
          } catch (e) {
            logger.error('Error Reading Response', e);
          }
        } else {
          try {
            const data = await response.json();
            logger.success('Response Data', data);
            
            if (data.success) {
              if (data.note) {
                logger.warn('Processing Note', data.note);
                output.innerHTML = `<p>‚ö†Ô∏è Note: ${data.note}</p>`;
              }
              
              if (Array.isArray(data.testCases)) {
                logger.success('Test Cases Array', data.testCases);
                output.innerHTML += data.testCases.map(tc => `<p>‚úÖ ${tc}</p>`).join('');
              } else {
                logger.success('Test Cases Text', data.testCases);
                output.innerHTML += `<pre>${data.testCases}</pre>`;
              }
            } else {
              logger.error('Processing Error', data.error);
              output.innerHTML = `<p>‚ùå Error: ${data.error}</p>`;
              
              // Still show test cases if they exist
              if (data.testCases) {
                output.innerHTML += Array.isArray(data.testCases) 
                  ? data.testCases.map(tc => `<p>‚úÖ ${tc}</p>`).join('')
                  : `<pre>${data.testCases}</pre>`;
              }
            }
          } catch (error) {
            logger.error('JSON Parsing Error', error);
            output.innerHTML = `<p>‚ùå Error: Could not parse response: ${error.message}</p>`;
            
            try {
              const text = await response.text();
              logger.error('Raw Response', text);
              output.innerHTML += `<pre>${text}</pre>`;
            } catch (e) {
              logger.error('Error Reading Raw Response', e);
            }
          }
        }
      } catch (error) {
        logger.error('Request Error', error);
        
        if (error.name === 'AbortError') {
          output.innerHTML = `<p>‚ùå Error: Request timed out after 30 seconds</p>`;
        } else {
          output.innerHTML = `<p>‚ùå Error: ${error.message}</p>`;
        }
      }
      
      logger.groupEnd();
    });
  </script>
</body>
</html>
